Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2024-07-23T23:08:41-07:00

====== ksp-gdc ======


all right well welcome everybody my name is Felipe I'm Lea developer on Kerbal

space program also known in the community as Harvester and joining me

today is Mike Elin over there he's our gaming tools developer and we're gonna

talk about KSP today and we've just got here and have no idea what the suck is

about criminal space program is a game about running your own space program so

you get to build spacecraft in a construction facility by assembling parts together and later launch your

proud space herring vehicle into space and one of the big things about Kerbal
Kerbal Space Program

space program is that failure is part of the fun and there's quite a lot of

failure along the way but once you manage to get up there you get accurate

orbital mechanics and an entire solar systems Explorer so you get to land on

other planets and moons splint your flag walk around the surface build space stations and construct spaceship by
2:55
docking vessels together in orbit and ultimately you're managing your entire
3:01
space program in career mode which is what we're developing at the moment because Kerbal space program is still
3:08
very much in development we've been following this iterative development
Development Method
3:13
method so we do we started out doing three week development cycles and every
3:20
three weeks we put out a new version which was supposed to be stable so our
3:26
focus is always on at the end of each release cycle we end up with something
3:32
that's playable even though it might not be complete it's stable enough and it
3:37
represents the concept as as well as it possibly can so on that screenshot is
3:44
see KSP version 0.3 we have a placeholder parts placeholder in UI
3:50
placeholder terrain really solder just about everything and from that version
3:56
which the max was when we started actually going full-scale with it
4:03
because up until here we were testing out basic mechanics and everything and KSP version zero point four was when we
4:10
started actually tackling the problem of doing terrain on massive scale and we
4:18
quickly ran into floating-point issues because I don't know if you ever tried
4:24
but if if you just move an object in the scene very very far away you start
4:30
getting all sorts of crazy effects and that's because you really require very
4:39
large numbers to do a space simulation and a 32-bit flow can only hold so much
4:46
so if you've got a relatively small number you get all the rest for your
4:53
decimal places and it's accurate enough but if your values start getting starts
4:59
getting like really really high then you need to start losing digits on the
5:05
right-hand side of the decimal point which means the higher you go the more precision you lose and eventually things
So how far can we go?
5:14
starts to break down so how far can we go with 32-bit floats just launching a
5:22
ship from the scene origin say the launch pad is at the origin and about 20 kilometers out you can see some
5:28
jittering already this is from version 0.3 you can see it's already slightly
5:35
jiggling at 100 kilometers out it's very visible I wasn't doing anything this is
5:42
pure jitter and if you go much further out things start getting like really bad
5:51
so we need to do something about that because really there's still a long way
5:57
to go here so the the solution for this
6:04
is actually well known in the year 3000
6:10
basically you don't move the ship you move the universe around the and this is
6:18
called floating origin so basically how it works is we set a threshold which in
6:25
our case is six kilometers and if we move it the ship past the threshold we
6:32
grab everything the ship meshes scenery
6:37
particles and we move it back so that the ship is back at the origin so what
6:44
this lets us do is that we can't really work around having to use 32-bit floats so the physics on a 32-bit transfer
6:53
matrices or 32-bit so it's not really about precision it's about resolution so
7:00
if we can stay near the origin we've got enough spatial resolution to
7:05
have a decently accurate simulation so the idea is that we're always near the scene origin and everything around us
7:13
can be built or rendered with nice enough precision and stuff that's far
7:20
away will slow jitter but it's far away so well it doesn't really matter as much
7:26
but we still do need a way to hold that beta in high precision and for that we
7:31
do need to use 64-bit doubles so what we did is we created clones of vectors and
7:38
quaternions called vector 3d and quaternion D which do exactly what vector 3 in quaternion do but with
7:45
double precision values inside they even have the same methods and everything so
7:50
we can do everything we did with you get any data types in there were precision so all our orbit maths and such
7:59
calculations are done in double precision and we store those in our controllers for celestial bodies
8:06
and orbits and stuff and then we assigned them to transform position continuously so as you approach an
8:14
object you this object is actually approaching you and it's approaching the
8:20
high-resolution space around you so this is how we manage to keep floating point
8:27
imprecision relatively under control but it's really an ongoing battle with it
8:33
because we found floating point issues just about anywhere one of the most
8:39
famous cases of course is a space kraken which is not because we're just going
8:46
very far we're getting there very very fast so the thing with the space kraken
8:52
it's a floating point imprecision also effects your velocity because velocity is also a 32-bit vector so and because
9:03
our ship it's not really just a single object it's made of several multiple
9:08
connected rigid bodies each one of them has its own velocity in it each one is
9:15
getting truncated and it's sewn different ways so the satans of being attacked by the Kraken include phantom
9:22
forces that steer you off course and this is the first manifestation as you
9:27
go faster you completely lose control and eventually things start coming apart
9:34
so a solution for that is Krakens Bane
9:39
yes we did the feat the Kraken eventually and it's basically the same
9:46
thing as floating origin but for velocity so what we did here was to create this reference frame which
9:53
absorbs the velocity of the vessel so that means we set a threshold for a maximum velocity you can have what
10:00
physically and after you exceed that threshold we zero out the velocity of the vessel and we update that and we
10:08
pass it along to the reference frame so instead of the ship moving very fast we
10:14
have this reference frame which holds double precision velocity value which
10:19
moves everything else the other way around so that way and we constantly
10:25
keep that updated so as forces act on the vessel like gravity and your
10:30
velocity changes we're also always ziering it out and applying it to this
10:36
moving velocity frame so when you slow back down whatever velocity still
10:42
remains on the frame we apply it back to the vessel and it uh it resumes normal
10:48
physics so that leads to see the setup of the universe and how we put it all
10:54
together so the big thing with KSP and how its set up is that we've gone so
11:00
scenes and some scenes are basically scenes within a scene on different
Subscenes
11:08
layers so each scene is rendered by its own set of cameras so they all exist in
11:17
the same space but they're rendered differently and they all can have their own reference frames
11:22
so in KSP we have three of those we have local space scaled space and internal
11:27
space and local space is our one-to-one scale main game environment where you
11:35
have your scenery and all the ships farts they all live in local space and
11:40
this is actually the scene orientation the Kerbal space center is actually
11:45
sideways because it sits at the equator of carbon so world space is a generally
11:52
meaningless term to us now and scale
11:57
space is or when you when you're sitting at the launch pad and you look up at the moon what you're seeing is actually the
12:04
scale space version of the Moon which is a 1 to 6,000 scale miniature of the
12:10
solar system which we use because it's much easier to manage these things on a
12:17
much smaller scale so for instance kerbin is only a hundred meters on scale
12:23
space so that gives us a much more usable area to work in
12:29
and sit and do stuff like rendering the atmosphere and rendering orbit splines and things like that and skill space
12:36
also doubles as a map to you but I will get into the in a bit third one is internal space internal
12:42
space is where we do our internal views which are used both for the inside cockpit view and the crew portraits you
12:49
see on the bottom right of the screen so
12:54
sorry so with internal space we when you're looking at it from the inside we render
13:01
only the internal space that contains the Kerbal you're currently possessing
13:08
and we remove his head as well so you can look around and the head mesh doesn't get in the way and as you switch
13:15
views we switch internal meshes and we remove heads as necessary and in the end
13:24
we put it all together like this what you see on the back of the fruit of this
13:30
layer gets drawn first and that's a scale space rendering which holds the the galaxy skybox the the atmosphere and
13:38
then the two metal ones are our local space we actually had to divide it
13:43
because even though we have the local space scale space thing going on senior
13:52
you still too large to be rendered by a single camera so we have a lot of z-fighting issues and the way we worked
13:57
around that was to have a new camera which renders everything from very close up to about five hundred units away and
14:05
then we have the far camera which renders from there on until it all fades
14:11
away and then you get scale space so on top of that we draw the UI or when
14:16
you're in internal view we draw the internal camera and what it renders so
14:22
it all renders on top of each other and it composes into a single image so next
14:29
up are the orbital mechanics themselves basically we had to make a big decision
14:36
here of how we were gonna simulate orbits and we ran into several issues with
Physics Integration Issues
14:43
physics and physics and physics integration basically problems our
14:53
physics our integration based and integration means that you compute the
15:00
state of an object based on its current state plus all forces acting on it so
15:05
you figure out its velocity you figure out the time step and you move it forward but the problem with that is
15:10
that the state of the object depends on the previous state so errors tend to
15:15
accumulate so what happens for instance if you're simulating an object orbiting a moon out in Jupiter
15:22
so that object way out there on in the boondocks or floating point and accuracy
15:28
is trying to do what it does but it's so inaccurate that it's probably gonna fall
15:35
out of the sky not to mention the moon itself being flung out and general mayhem like that so and apart from that
15:43
you have issues with time warp because you either speed up time and you drop
15:48
frames and you lose accuracy or you simulate sub steps and you completely
15:54
kill your computer trying to do a hundred thousand times warp factor so
16:01
not very viable for us so this is why deterministic physics are cool so
Deterministic Physics are cool.
16:08
instead of the computing your your rigid bodies through integration we run two
16:16
body solver which is basically using another set of values and another set of
16:24
a maths to calculate the problem so the state of the object becomes a function of time you can figure out where
16:30
something is gonna be just by passing in a time value which means you get to do
16:36
stuff like scrub time and time work becomes really very simple because all we need to do is multiply the ongoing
16:42
clock and with the single universal time value we can resume to save the entire
16:48
system so we don't need to save where everything is out in order but we just say one
16:54
universal time value and the whole solar system adapts to it so it's all
17:01
persistent and very reliable and there's no compromise and accuracy whatsoever because all you need is that one time
17:07
value and it's fun as well because these textbook type physics are very much what
Deterministic Physics are fun, too.
17:15
you find in a physics textbook so when you're trying to teach about physics and stuff like that usually it's well look
17:23
at how it went but it's not really like this because you have to account for a drive you have to account for gravity not being uniform and all that sort of
17:30
stuff in case people decided to do away with all that and really what you see is what you get because perturbations in
17:38
practice just tend to look like noise I can just imagine people coming to the forums complaining like hey my space
17:44
station dropped out of the sky and I have no idea why and we say well that's not a bug it's a feature well it's kind
17:49
of hard to explain thousand time around so it's nice that we don't we have no
17:56
difference between the actual trajectory and the predictive one because it's solved using the same math so the big
18:04
trade-off though is that there can only be one gravity source at a time so that becomes a bit of a thing that we have to
18:11
work around and we do that by using the concept of spheres of influence so we do
Spheres of Influence
18:16
multiple gravity sources one at a time so basically we figure out what the
18:22
dominant celestial body is based on where you are and if you're inside its sphere of influence and we calculate
18:29
your orbital parameters as you transition so that's how we do being
18:36
able to go around and rub around a moon and stuff like that so these are your
Orbital Parameters
18:42
orbital parameters we use them in two ways we calculate them from position and velocity for vessels and for planets and
18:50
moons they're manually defined so we basically build out the planetarium like
18:55
this by just setting the orbital parameters for each planet and for each moon and we let them orbit based on the
19:02
game clock and for spacecraft we have what became known as the rail system which is
19:07
basically the same thing for spacecraft but the thing is here for spacecraft we are running physics but at some points
19:14
we have to stop using physics and switch to the deterministic system which is
19:20
something we call going on rails what happens there is that all rigid bodies go kinematic then your controller
Going "On-Rails"
19:27
switches to driver mode instead of just tracking and we calculate position and
19:33
velocity from two body solver instead of physics and the same thing happens in
19:39
Reverse for going off rails which we may call rigid bodies non kinematic again we
Going "Off-rails"
19:45
get the velocity from the two body solver and we basically throw the vessel
19:50
back into physics and then your Wii controller global goes back into being just a tracker and updating its own
19:57
orbital parameters from the vessel and just watching it happen and then next up
20:04
is drawing orbits so to draw the splines we needed something to draw a line so we
Drawing Orbits
20:11
use a plugin called electricity to do the spline drawing and basically we
20:16
build the orbits plane just by using the solver we sample it along its course so
20:23
that gives us a very nice way to just to give rabb an array of points by sampling
20:28
the orbiter as it goes and and then we render it out in scale space so skill
Scaled Space doubles as Map View.
20:38
space then double says or map view so when you hit em and you zoom out to the
20:43
map what happens is we disable the local space camera so you don't see the scenery and you don't see the vessel and
20:49
we fade in the orbit splines and then we disable the skills camera script which
20:55
is basically just a little script that tracks the local camera and applies the scale factor to it and on the same
21:02
camera we enable the map camera script so that's how we do the map view just by
21:09
switching the camera behavior and this map view was really important because the big thing about case
Situational Awareness in Space.
21:15
that it needs to be approachable and the problem the main problem I see with rugged science is that uh you have a
21:23
severe lack of situational awareness you really don't know what's going on because it wasn't like a real easy
21:30
intuitive way to see it so the biggest challenge I think in KSP was this was how to convey what's going on in a way
21:39
that's visual and informative but without just dumping a lot of data on
21:44
the player so the map is fully 3d and you're free to move around and you're
21:49
free to focus on different objects and view your orbit from every angle so that
21:55
way you get this much more intuitive understanding of what's going on just because of the way it's drawing in 3d
22:03
space and you can move the camera around and see it from different angles so we
22:08
only show numerical data when it's really needed so this is why we have things like sorry too early when you get
22:18
to when you hover over the nodes on the map view then we show what the node is
22:24
and what its values are so we're not flooding the players with numbers all
22:29
the time because otherwise it's very easy to just fill the screen up with numbers and end up with something very
22:35
unattractive so finally we patch orbits together to
Patching Orbits Together.
22:42
do to do the full trajectory display now
22:47
I had a thirty more slides on this and I could go on and Leslie but uh it's not
22:53
gonna be enough time to cover how we do this but basically we use a rail system to predict where you're gonna be and
22:59
where each planet is gonna be by the time you get there and from that we figure out what your next orbit is gonna
23:05
be inside the sphere of influence of that other body and so on and so forth
23:12
until we either reach some sort of limit or we reach in orbit where you can't
23:18
where you don't find I need more encounters or escapes and we display
23:23
that using different time reference frames
23:28
I call it you can see that as you encounter the moon you don't really see your orbit around the moon you see it
23:34
orbit around the moon in relation to carbon because the moon is also moving
23:40
so we're really essentially trying to show 4d data in a 3d space and there was
23:47
a good deal of a hab bashing to figure out a way to show this in a way that makes the most sense yet eventually
23:54
settled with this which is that we show your orbit locally for the planet you're orbiting and if you encounter a planet
24:02
somewhere ahead we show that or a bit in relative frame which is what we call that each point is sample at the spot
24:10
it's gonna be at that time so that gives us some nice of squiggly line where you
24:16
can see things like how you encountered the moon loop around it and jump back so
24:25
that's basically how we do it forgot those and so you know this is another
24:33
interesting part of the the game that I you felt was worth showing the reentry
24:39
effects and how we did that basically the problem with reentry effects was that we wanted the ship to look like it
24:45
was catching in fire and you could see the plasma like looking the shape as it
24:52
went but the big problem with this is a on more conventional game you'd have
24:58
this effect done for the specific ship and have another version of it for another ship and so on
25:03
but we don't know what the ship looks like we can just build anything so we needed to find a way to do this effect
25:10
that would support any configuration of something you might build and apart from
25:16
that we ran into another problem which is no one really knows what reentry effects look like there's a lot of image
What does re-entry really look like?
25:24
images on the internet if you just look for it but you can see that of all of
25:30
these they're all artist's rendering none of them are actually a picture new
25:35
ones that were you can't find like a really nice picture with what the reentry effect looks like so in the end we
25:43
settled in trying to achieve this look which we broke down into two components
FX Components
25:50
the heat glow and the flame trail so for the heat glow we try a couple of things
25:57
and we try we thought about maybe an emissive texture or something like that
26:03
but the emissive map was tricky because we don't really know the orientation of the ship so which way of it is actually
26:10
facing the incoming air stream and well
26:15
eventually worked best was to just use a light an orange light placed along the
26:22
velocity stream so that was much easier actually so the flame trails were
26:30
trickier the first attempt we tried to use God race and look it looked close to
26:39
what we wanted to achieve but it doesn't work unless your scene is a black backdrop with nothing else on it this
26:45
doesn't work at all so we'd get flame trails on the UI on everything so and it
26:53
generally broke down so the second attempt was something more I remembered
26:59
seeing this effect for first shaders and free shaders work by having by drawing
27:06
the same object again and again using shells and just having a transparent texture and I thought well maybe we can
27:14
abuse this in some way so I got a free shader and started tweaking and modified
27:21
she's appreciated gave us this result basically we draw a multipass shader and
27:27
all of the shells are offset progressively along the well the
27:34
opposite of the velocity vector so they're running away from you and we and
27:40
on top of that on each pass we run
27:45
slightly different parameters for opacity in color and things like that
27:51
so that started to look real nice and we do that we render it out in the game by
27:57
using replaced shaders and an effects camera on top of all the other cameras we already had so um it's just one more
28:05
camera at that point so we rendered the ship as normal and then we run the
28:11
effects bus which renders it again with a replaced shader and but the problem
28:18
with that is it worked a little too well so every face would be on fire even back
28:27
faces so that didn't look really right we get the the burning window effect as
28:34
it was named by the community so the way we solved that was to do essentially
28:40
shadow mapping we got a camera along the velocity vector that renders the ship
28:47
whether that flexure and we projection map this step texture onto the ship and
28:53
then on the shader we can check if the for each vertex if the depth of the
29:01
vertex matches the depth on the map and if it doesn't we occluded and if it does
29:08
it means that it's actually exposed to the air stream so that way we can mask off the areas that are occluded in
29:14
they're not on fire and that pretty much solved the issue and then lastly we use
29:22
an animated texture map to actually modify the extrusion length of each pass
29:28
that required us to use a vertex texture read which thankfully was possible on
29:34
jaden 103 so this screenshot doesn't
29:40
really convey what actually happens there is a video later on and we
29:45
actually got a nice bonus feature from this we got just by tweaking the parameters and the way we scaled the
29:53
offsets we got to do mac effects which basically use the same approach just
29:59
with tweaked values so here we've got a
30:04
little video of the orbiting space station in the name of science and I'm
30:12
not getting into wait why is this not
30:17
playing ma'am sorry minor technical
30:22
difficulties oh it's because we're not
30:28
connected
30:33
but they didn't get on the Wi-Fi that we we're not anymore um might have to skip
30:41
this board sorry if we can get the connection back later we'll come back to
Procedural Quad Sphere
30:48
it so next up is the terrain and for that part we we've got Mike who is at
30:58
fault for all that so testing hello
31:08
so our train system is called the procedural quad sphere or pqs basically
31:20
it's a method we use rendering the
31:26
terrain so we've got some sample shots here's a nice little mountain range and
31:31
some planes in kerbin here's another mountain range and some lovely trees
31:37
scatter here's a view from KSC showing
31:44
some more mountains actually so the aims of the system first of all we needed to
PQS Aims
31:51
ground to a bit level of detail system pretty important in space game we needed
31:57
planetary scales kerbin is 600 kilometers in radius which is a couple
32:06
of million square kilometers we need to have a huge variation on the planets
32:13
themselves I'm between the planets and something that's not you know
32:20
immediately evident but it's quite important is we need to be able to sample the terrain without building the
32:26
mesh or building colliders so we can rake us-against-them this allows us to do lots of things
32:32
radar altitude and collision on objects which we're not in orbit of so for other
32:40
ships in the solar system so what is a quad Sphere it's a spare made of quads first of all
What is a Quad Sphere?
32:50
we start with a distorted cube base and then we use a quadtree subdivision to
32:56
get the level of detail increases so what what does this look like here's
33:02
something which will never happen in the game it's a minus 1 sphere this would
33:09
never happen because we never store the planet like this so I've had to mock it
33:15
off with planes in unity each each plane is 16 by 16 vertices then we do a few
33:24
operations on it and we end up with the level 0 sphere so this is the lowest resolution thing that we can have in the
33:30
game as you can see the 6 planes are now mapped to the surface of the sphere here
33:39
is one of the planes selected you can see it's a nice curved shape and they
33:44
all match up edgewise so it's level 1 we've got 4 times the number of vertices
33:51
here and you can see that the same plane that we had in the other one is
33:58
subdivided into these four planes and let's move to level 2 so we can see that
34:05
the upper-right quadrant we had in that plane has now been subdivided into 4
34:12
giving us 4 4 times as many vertices
34:17
level 3 I'm getting quite a lot of vertices now level 4 pretty hardcore and
34:25
level 5 is pretty black so how many
34:31
vertices have we got kerbin 600 kilometers radius so the vertex
34:39
resolution is 75 kilometers in a level 0 sphere 1500 verts quite handleable the
34:48
level 5 SVC is 2.3 kilometers vertex resolution but it's 1.5 million the
34:56
which is pretty extreme now most fears run up to level 10 in the
35:03
game which if we rendered it straight out would be 73 meters resolution which
35:08
is adequate for the game but it's 1.6 billion verse which unity would not
35:15
render surprisingly so we need to use
Adaptive subdivision
35:21
adaptive subdivision and to do this obviously we need to use distance to the
35:26
camera we use various types of distance we've obviously got the linear distance
35:32
but we've also got the Great Circle distance around the sphere and the
35:37
algorithm to calculate the subdivision is quite complicated I'm not going to go
35:44
into it but you asked me later I will do quite important is only subdividing
35:52
ourselves one level higher than our neighbor quads this is quite important
35:59
because if you start to have four neighbor quads it gets quite complicated and we have the next point which is we
36:07
need to avoid cracks so here's a level
36:12
zero to ten sphere you can see that the
36:18
where the subdivision changes it's only one subdivision level higher where the
36:25
tiny white circle is on the left that's where the cameras placed and under that will be subdivision level ten on the
36:32
opposite side of the sphere would be subdivision level zero how quickly that
36:38
changes depends on parameters we enter but is all to do with the radius Great
36:43
Circle distance it's quite complicated so the dreaded cracks and now if we just
36:51
do it simply we end up with nasty cracks which you can see here the quad in the
36:59
lower left is one subdivision level higher than the rest so its vertices
37:05
have it's quads of twice as many verse so we end up with potentially as the vertexes change so we
37:14
use a geomap mapping technique called well edge funds where we lurk the edge
37:21
triangles so that they skip vertices so
37:28
that they match up with the lowest subdivision on the other side
37:34
now there's doing this high-performance
37:40
is quite tricky but quite simple when you think about it there are only 17
37:45
possible edge conditions for every quad the first one being that we are the same
37:51
subdivision as all our neighbors so that means we just render a straight quad
37:56
with all triangles then we we've
38:02
obviously got if the North Edge has two neighbors or the South Edge has two
38:08
neighbors or three edges have two neighbors or all four edges have two neighbors which would be pretty rare but
38:15
it's one of the edge conditions so it's one plus four to the power of two or
38:23
something so what we do is for each one of those edge conditions we case your triangle array and then we use a bitmap
38:32
bit mask to select the correct one this means we don't have to re triangulate
38:38
quads as we need to so here we are possible education this is our bit mask
38:46
so we assigned a value of 1 2 4 & 8 to the respective edges let's have a look
38:54
at that so here we've got a quad which has itself and East edges need loping so
39:02
using the bitmap we need to lower east and south which would be 2 plus 4 so it
39:08
would be the 6 index on the triangle array and as you can see we've got no
39:15
cracks now which is nice so how do we generate a quad first
Quad Generation
39:21
things first we need to generate diversities second thing we obviously
39:26
select our triangle array then we create the mesh data which is just as simple
39:34
dumping the things into unity mesh for
Vertex Generation
39:39
each vertex we take our cached x-z quad and then we transform it with the TRS
39:46
matrix this moves the points into a into
39:53
the quad scale the quad orientation and then we need to normalize it which gives
39:59
us the direction of that vertex from the centre of the planet then we need to
40:05
generate the height and we also generate a vertex color in if we are using vertex
40:12
channels on the planet so here is our
40:17
impossible quad this would never exist in the game we run it through the matrix
40:25
and normalize it to get our distorted quad and then push push it through the
40:33
generator to get some variation in height in color now how we generate the
40:39
height in color is all down to something we call peak us mods picaresque mods
PQS Mods
40:45
make planets good so here's Doudna looking rather resplendent so pqs mods
40:56
are simple monobehaviour components we attach two sub objects are the pqs
41:05
they're compiled that start up into method chains which means that we can
41:11
just call the vertex build height method and it will execute all the entire chain
41:18
they control all aspects of the planet life lifetime the obvious one being terrain
41:25
generation as we just said but there's also the game interface the pqs system
41:31
was developed as a separate module so the game
41:37
controls the peak us through the mods and the peak us well is a very dumb
41:43
system so the mods controlled the peak us is a sort of like feedback loop we've
PQS Mod Types
41:49
got a few types of peak us mods I've got a vertex mod which comes in two flavors
41:56
high in color there are also color high or high colored mods we've got object
42:02
placement and visibility so these position cities and objects on the
42:09
surface they also control a level of detail of those objects we've got level
42:16
of detail of the pqs itself so for instance we might want to increase the level of detail of the coastal quads to
42:24
give her a nice nicer coast so we've got mods to do that and we've also got
42:31
material and shader mods these are there's some quite complicated shader
42:38
work in a pqs depending on how the planets rendered so that's all done
42:43
through the mod mod so we've got a few methods in a generic mod on setup this
PQS Mod Methods
42:52
method gathers requirements that the mod has so potentially it has vertex color
42:58
channel or it requires custom normals or well the whole host of requirements and
43:06
these can change how the pqs generates itself if it requires longitude and
43:12
latitude for each coordinate for doing texture mapping or all the types of
43:17
mapping the on sphere star is how the pqs controls its startup so the first
43:25
time it starts up it'll run it's on sphere star and there might be a mod
43:30
which says don't stop now so that sort of turns it on and off
43:36
then we've got on vertex build height which is the classic build height when
43:41
we want to generate the terrain height for position this mod weld the on vertex
43:48
build height methods have run so it just generates the height it doesn't generate any color or anything lower and then
43:57
we've got build color if we're using vertex colors and on quad bill is used
44:03
for assigning scatter or a variety of other little tricks that are per quad
44:09
there are about 20 of these methods so not going into all of them
44:15
so very simple example here is a blank sphere add a simplex noise onto it
44:24
simplex is like a pearl in noise but it's a bit faster at higher octaves so
44:29
we tend to use it quite a bit then we use a clamp height mod so it makes a
44:36
nice little ocean type moon enhance ridges to kind of remove some of the
44:42
fractally the cloudiness service simplex or a pearl in there can be quite cloudy
44:47
and repetitive despite being fractals and then run a bit of height based color
44:52
on top as well so we've got a nice little landscape there so quick talking
Shader Techniques
44:59
shader techniques we obviously use vertex color blending there's a variety
45:05
of ways to do this we've tried lots yeah
45:12
you can spend a long time blending vertex colors we use it a try planar
45:17
texture mapping technique to texture the actual planet triplane is good because
45:22
if you have ever ever tried to texture map a sphere you struggled because the
45:28
UV coordinates have to have a seam and generating that on the pqs at runtime is
45:34
quite tricky your sub normal mapping to make our ruggedness a bit more rugged
45:39
and there's two other techniques we use distance-based multi texturing so we
45:47
have the detailed texture up close and further away we it comes fuzzier to avoid scaling and slope based multi
45:55
texturing so the higher the slope the more rocky I get or if it's flatter
46:02
it might have a bit more Sund on it something here's a look at what a triplane texture map looks like it's
46:09
texted over three planes since the name we've got an x y&z texture and with some
46:17
additional mesh information you can generate a UV coordinate from the XY is
46:23
that coordinate and use their try playing a technique and as you can see
46:30
without the grid and with a normal texture it looks it looks quite nice we
PQS Rendering
46:37
can also do smug things we can render a peak us out we can render it to texture
46:42
maps and we can also use grayscale height maps which we can then re-import
46:48
using the grayscale to normal normal map and we can use data maps as well because
46:56
some pieces are not generated as planets but we use them as basis for other types
47:01
of maps the the Sun texture is generated using a shader with three data maps from
47:10
a peak us it's very good for generating spherical data sets and we can also
47:16
generate a mesh and generally what we do is we wrap a geosphere mesh around a
47:22
peak us to generate the planet message for scaled space so here's his kerbin in
47:29
scaled space this has been rendered out to a normal map and a texture map so
47:36
these are just from the vertex colors and from the vertex heights we tend to
47:42
not use a mesh on planets with oceans so the blue color is actually defined by
47:48
the renderer and this is because the coasts if you have a mesh look a bit odd
47:54
without doing some level of detail on the mesh router itself some smaller
48:01
moons here's Paul using both well three normal texture and a
48:09
rapper so you can see it's got lots of height so when we blend between scale
48:14
space and local space it blends nicely
48:19
we've got fall as well which is an icy moon of Joule and Bop which is a bit
48:25
boring but it's quite lumpy so that's a good example now just a quick talk on
48:31
modding KSP where wonders never cease
48:36
we're often astounded by the things people can come up with so the early
KSP's Early Setup
48:42
setup of KSP there were part cold modules and these were things like a
48:50
command part wingler engine fuel tank control surfaces struts all these sort
48:59
of things were a single code module it had a text-based camping system which
49:05
was pretty basic a Dae model loader which was again pretty basic and we
49:13
could load PNG and JPEG textures
49:19
obviously when you give the promise of being able to mod things to people they
49:26
kind of go above and beyond what we expect so we had a user which took the
49:33
KSP DLL he compiled it he then injected DLL
49:38
loading code he recompiled it and at
49:44
this point we're all thinking this could be terrible but what he did was actually
49:50
send the results tools first to say you know can I distribute this thing we said
49:55
no but we hired him anyway so Rob now works for us I think he's on
50:03
the web team but suffice to say the fruits of his Labor's are still still in KSP so having all this dll loading
PartModules
50:13
things made as no we needed to change the way that parts worked so we made a
50:21
move towards part modules basically parts have multiple part modules this
50:28
means that the part code goes from defining all of the logic to just defining the attachment logic so there
50:37
are pretty much the only two types of part now there's a standard part which is it can attach to or the parts and
50:44
there's a struct which has a start in an endpoint and then would define itself as
50:50
those attachments the part module then defines the functional logic so we've
50:58
got the command modules the engines the fuel tanks the wings all of those goodness goes into power modules this
51:06
gives us a lot more flexibility and allows us to have a single part which is a lifting body an engine a command pod
51:12
all rolled into one which would have been obviously impossible in the old system and then we've got internal space
Internal Spaces
51:21
definitions in tails places varieties are quite late only a couple of updates ago parts can have a single internal
51:29
space definition an internal space has a
51:34
single mesh object which it can load in but to give it variation and to
51:43
obviously have control we have things called internal props and internal space
51:49
can have multiple internal props and then internal props then have a single
51:54
mesh object but to give them variation they have multiple internal modules so
52:01
they become parts in a way and then our part internal modules are sort of like
52:07
part modules so you could have a nav ball which is a fuel display as well
52:12
and all these things but everything from a seat to an internal camera are all
52:18
defined in internal modules through the config system so our comping system got
ConfigNode
52:25
upgraded to something we call config node it's its main aim was to be
52:32
backward compatible with all the old config so we couldn't switch to using a
52:37
proprietary or you know a standard JSON type system basically it's a
52:46
standardized text-based config system which consists of a hierarchy of nodes
52:51
and values and it's compiled and passed situationally meaning that whoever's
53:00
compiling the whoever's loading and compiling the come Fink can do so in any
53:09
way they like so we're not restricted on what's actually inside these config knows here's a sample one from the
53:17
Coppola part you can see it's got a name which is you need a new knee ID it is a
53:25
part which is a standard part it's got a category mass a drag drag model type
53:31
it's then got to module nodes one of them is a command module which says it
53:37
requires one minimum crew to operate properly it's got a SAS module and then
53:43
it's got an internal space definition which is the in a Coppola internal which
53:50
it would load via that name then we've got mu files new files are a custom
54:00
model file format that we use inside they contain a full unity hierarchy with
54:06
a whole host of things which you can output from the unity editor and they're
54:12
set up and compiled by a unity editor plugin which is well this is the current
54:19
self so we've got the part part modules internal space blah blah blah
54:25
we use the config note system we have a DLL loader to stop people right in their
54:32
own we use da and meu we've got a whole host of texture formats so the part
PartTools
54:40
tools is what we use to generate user content it's a unity editor plugin
54:46
it allows people to compile assets you can create new files you can convert and
54:52
create textures you can load save and create internal space config so this is
54:58
the position of the props and the
55:04
modules and things that are on them here's a little screenshot of part tools
55:09
running an internal thing as you can see you can spawn various components and
55:16
snap them and all that goodness right I think where's quickly running out time
55:22
I'm going to hand over to Felipe quickly for the final stint oh it's so pretty
55:34
short time so we're gonna keep this quick as much as possible so well KSP is
55:43
still being developed so we can't really say we've learned from it and that's it
55:49
we're still learning we're still going and but if there's one thing that I
55:54
guess made all the difference way of KSP was that kerbals make it more
56:02
than just a game about building spaceships so they're that a humanizing
56:07
element they're what makes players relate to the game because now you have something you to care about or it's a
56:15
gleefully kill as needed so so but in
56:21
earnest interestingly enough we had no idea what kerbals would look like when we started so when we started we knew we
56:29
wanted them to have like big heads and bulging eyes but we didn't really know
56:34
what they were me so the design kind of evolved into this and then they grew hair so this is
56:44
a already rigged up for appearing on a credible portrait and we
56:49
just made sure that their head meshes bent far enough that they could express
56:54
their delight or panic but really and then we realize we have this whole universe of kerbals they were just
57:01
beginning to develop so there's a lot to take from this we don't really have a
Development Model
57:09
lot of time but uh so I'm gonna skip this so and and but uh going on
Community Feedback
57:26
community feedback I think this is was one of the biggest things for us when we started developing ksb we had a lot of
57:33
open questions and because we released very early we were able to get community
57:39
feedback at a point where it was actually very useful to us so for instance we didn't even know
57:44
whether or not we were gonna leave the orbital mechanics in the game or not because we thought it might have been
57:50
too complex so when we release not only we discovered that people liked that
57:56
they wanted more so so we kind of shaped away development went just because just from based on community feedback the one thing to take from that is that they can be very honest so you need to be ready for that because it's not all praise and eventually we get to a point which I call the feedback threshold which is the point where where your feedback can start to become misleading because players the really players that have been playing the game for over a year now want things that are different from what the new players need so you kind of have to balance so that's something that we're still it's an ongoing thing so we're always trying to balance on each update the features we add and stuff like that so make sure that it's entertaining for for it's something that it's good for new players and it also something of value for players that have been added from the beginning so that's it I guess there is alright thank you so very much there will be coffee in ballroom see if you want to join us and have a great rest of the day thank you so much [Applause]
